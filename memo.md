# C++ 備忘録

## NOTE
- Notice
    - オーバーフローに注意。謎バグとれなかったら、大きい境界値で試してみる
    - 約数列挙でd * d < N みたいな判定すると、左辺がOFすることあるので注意
        - やるなら、d < N / d
- 整数
    - [典型] 交互に引き算するのはGCDに対応
    - [典型] 片方から引き続けるのは%=に対応
    - 整数a, b, c なら a * b > c と a > c / b は同値
- bit全探索
    - 2^20、3^16 あたりは間に合う
    - [典型] 部分集合の全探索は3^Nでいける。for(S ⊂ A) for(T ⊂ S) {}; 
        - rep(s, 1<<N) for(ll t = s; t > 0; t = (t-1)&s) {};
        - EDPC/U
- BFS
    - [典型] BFSの計算量は"queueにpushされる最大回数"
    - 直感より小さいことがある
        - AGC044/B
- DP
    - 大事なこと：まず動くDPを作る。それから状態をまとめたりして計算量をへらす。
    - [典型] 挿入DP
    	- どんなとき？
	    - 1..Nを並べるような、順列ぽいやつ
	    - dp[i][j] := 左からi番目まで並べて、右端がそれまでj番目のときの場合の数
    - [典型] メモ化再帰
        - どんなとき？
            - 状態数が小さいことはわかる
                - AGC044/A
            - 漸化式だけ立ってる
            - 良い順番があることはわかる
            - その順番がよくわからない
            - DAGの最長パス
                - EDPC/G
        - 状態を連番で表現しづらい場合はmap使う
            - AGC044/A
- 最大フロー/最小カット
    - 頂点を追加すると最大フローで解ける問題がたくさんある（ABC010/D）
- 二部グラフ
    - 二部マッチングはStart -> 赤全部、青全部 -> End にコスト1の辺を追加して、最大フロー = 最大マッチング数
        - AOJ/1163
    - 二部グラフの最大独立集合のサイズ = 頂点数 - 最大マッチング
        - SoundHound-2018-Spring/C
    - 二部グラフでない = 奇サイクルが存在
- 座標圧縮
    - 線分を引く場合は、座標を2倍して、偶数座標は線分用の幅0マスとして扱うと実装が楽になる
        - ABC168/F
- ダイクストラ
    - [典型] 拡張グラフ上のダイクストラ := （頂点、距離）+ a の情報を持ってダイクストラする。priority_queueで自分で組んだ方がバグらない
        - JOI2017yo/F
- 木
    - [典型] 全方位木DP
        - 頂点に対するDPというより、辺+向きに対するDP
        - 木は適当に根付き木にすると、根以外の頂点と辺に対して一対一対応ができる。2種類の向きのためにDP1、DP2を用意して、それぞれ回せばOK。
        - 任意MODの場合は掛け算の逆元がないので、少し面倒。左累積、右累積を使う必要がある。
            - EDPC/V
- 幾何
    - 平面走査
        - [典型] 偏角ソート
        - [典型] 偏角でグループ化
        - [典型] 偏角扱う場合は、atan2でソートすると誤差で死ぬことがある。ベクターライブラリを貼って、偏角ソートするのが安全。
            - ABC139/F
- multiset, priority_queue
    - ほぼ同じことができる。要素をソートして保持。先頭要素取得：O(1), 挿入・発見・削除：O(logN)
    - multiset
        - 両端を*set.begin(), *set.rbegin()で参照
        - set.erase(x) は全削除。set.erase(set.find(x)) が1個削除。返り値は削除された次の要素のイテレータ
        - ABC170/E
- XOR
    - よく使う性質
        - a^b = b^a
        - a^(b^c) = (a^b)^c
        - a^a=0
        - a+b = a^b + 2(a&b)
        - x^(x+1) = 1
        - x^(x+1)^(x+2)^(x+3) = 0
    - [典型] 入力全てのXORをとって、a_iと何かする

## ToBe
- 座標圧縮

## ペア
- 作成
```c++:
vector<pair<int, int>> p;
p.emplace_back(1, 2); // 末尾に(1, 2)を追加
p.emplace(p.begin(), 1, 2); // 先頭に(1, 2)を追加
```

## マップ
```c++:
map<int, int> mp;

// イテレーション
for (auto p: mp){
    f = p.first;
    s = p.second;
}

// 削除
mp.clear();
```

## ビット演算
- 2^n 全探索
```c++:
for(int mask = 0; mask < (1 << n); mask++){
    for(int i = 0; i < n; i++) {
        if(mask>>i&1) {
            // i ビット目が1の場合の処理
        }
    }
}
```

## 文字
```c++:
// char to int
char c = '9';
int i = c - '0'; // 9

// int to char
char c = 9 + '0'; // '9'

// アルファベットをずらす
char c;
c = 'a' + 25; // 'z'
c = 'z' - 1;  // 'y'

// アルファベットをループ
for(char c = 'a'; c <= 'z'; c++) {
    // 処理 
}
```


## 文字列
```c++:
// 結合
str = str1 + str2;

// i番目からj文字抽出
s = string.substr(i, j);

// ループ
string s = "abc";
for (char c: s) cout << c; // a b c d

// string to int
string s = "123";
int n = stoi(s); // 123

// int to string
int n = 123;
string s = to_string(n); // "123"

```

## 数学
```c++:
// 円周率
double pi = M_PI; // 3.14159...

// 三角関数
double theta = M_PI / 2.0;
cos(theta); // 0.0
sin(thta); // 1.0
asin(1.0); // M_PI/2
acos(-1.0); // M_PI

// Log
double m = log2(16); // 4

// べき乗
double m = pow(2, 3); // 8

// 最大公約数
// stdに__gcd がある
// C++17からstd::gcd が追加
int m = 10, n = 4;
int = __gcd(m, n); // 2
int = gcd(m, n); // 2
```

